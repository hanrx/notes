
# [README](../README.md "回到 README")

Java提供了丰富的运算符环境。可以将大部分**Java运算符划分为4组：算数运算符、位运算符、关系运算符以及逻辑运算符**。Java还定义了一些用于处理某些特定情况的**附加运算符**。本章将会介绍除**类型比较运算符instanceof和新的箭头运算符->**之外的所有Java运算符，instanceof运算符将在第13章学习，箭头运算符将在第15章学习。

## 4.1 算术运算符

算术运算符**用于数学表达式**，使用方法与代数中的使用方法相同。表4-1中列出了算术运算符。
![](images/4.1.1.png)
算术运算符的**操作数必须是数值类型**。不能为boolean类型使用算术运算符，但是可以为char类型使用算术运算符，因为在Java中，**char类型的本质上是int的子集**。


### 4.1.1 基本算术运算符

基本算术运算符——加、减、乘和除，对于所有数值类型来说，行为可能和您期望的一样。**一元减号运算符对其唯一的操作数进行求反**，一元加号运算符简单地返回其操作数的值。请记住，**当将除法运算符用于整数类型时，结果不会保护小数部分**。
![](images/4.1.1.1.png)
![](images/4.1.1.2.png)


### 4.1.2 求模运算符

求模运算符%可以返回除法操作的余数，既可以用于浮点数，也可以用于整数。下面的示例程序演示了%运算符的用法：
![](images/4.1.2.1.png)


### 4.1.3 算术与赋值复合运算符

Java提供了可用于将算术运算和赋值组合到一起的特殊运算符。你可能知道，类似下面的语句在编程中非常普遍：
![](images/4.1.3.1.png)
该版本使用+=复合赋值运算符。这两条语句执行相同的动作：都将a的值增加4。

![](images/4.1.3.2.png)
对于这种情况，%=得到a/2的余数，并将结果存回变量a中。

对于所有的二元算术运算符，都有相应的复合赋值运算符。因此，以下形式的所有语句：    
![](images/4.1.3.3.png) 

复合赋值运算符具有两个优点。首先，便于输入，因为它们是与长格式等价的“简化版”。其次，有时候**它们比等价的长格式版本的效率更高**。所以，在专业的Java程序中，会经常看到复合赋值运算符。
![](images/4.1.3.4.png)


### 4.1.4 自增与自减运算符

++和--是Java的自增和自减运算符。在第2章就已经遇到过这两个运算符。在此将详细讨论它们。在后面会看到，它们有一些特殊的属性，使得它们非常有趣。首先让我们准确地考察自增和自减运算符的行为。

**自增运算符将操作数加1，自减运算符将操作数减1**。例如，下面这条语句：
![](images/4.1.4.1.png)

这些运算符比较独特，它们既可以显示为后缀形式，紧随在操作数的后面；也可以显示为前缀形式，位于操作数之前。在前面的例子中，采用哪种形式没有区别。但是，当自增和/或自减运算符是更大表达式的一部分时，两者之间会出现微妙的、同时也是有价值的差别。对于**前缀形式，操作数先自增或自减，然后表达式使用自增或自减之后的值；对于后缀表达式，表达式先使用操作数原来的值，然后再修改操作数**。例如：
![](images/4.1.4.2.png)
![](images/4.1.4.3.png)
![](images/4.1.4.4.png)


## 4.2 位运算符

Java定义了几个位运算符，它们**可以用于整数类型——long、int、short、char以及byte**。这些运算符对操作数的单个位进行操作。表4-2对位运算符进行了总结。
![](images/4.2.1.png)

由于位运算符是对整数中的位进行操作，因此理解这类操作会对数值造成什么影响是很重要的。特别是，掌握Java存储整数值的方式以及如何表示负数是有用的。因此，在介绍位运算符之前，先简要回顾一下这两个主题。

在Java中，所有整数类型都由宽度可变的二进制数字表示。例如，byte型数值42的二进制形式是00101010,其中每个位置表示2的幂，从最右边的20开始。向左的下一个位置为21，即2；接下来是22，即4；然后是8、16、32，等等。所以42在位置1、3、5（从右边开始计数，最右边的位计数为0）被设置1；因此，42是21+23+55的和，即2+8+32。

所有**整数类型（char类型除外）都是有符号整数**，这意味着它们既可以表示正数，也可以表示负数。Java使用所谓的“2的补码”进行编码，这意味着**负数的表示方法为：首先反转数值中的所有位（1变为0,0变为1），然后再将结果加1**。例如，-42的表示方法为：通过反转42中的所有位（00101010），得到11010101,然后加1，结果为11010110，即-42。为了解码负数，首先反转所有位，然后加1。例如，反转-42（11010110）,得到00101001,即41,所有再加上1就得到了42。

如果分析“零交叉”(zero crossing)问题，就不难理解Java（以及大多数其他计算机语言）使用2的补码表示负数的原因。假定对于byte型数值，0被表示为00000000。如果使用1的补码，简单地反转所有位，得到11111111，这会创建-0。但问题是，在整数数学中，-0是无效的。使用2的补码代表负数可以解决这个问题。如果使用2的补码，1为加到补码上，得到100000000，这样就在左边新增加了一位，超出了byte类型的表示范围，从而得到了所期望的行为，即-0和0相同，并且-1被编码为11111111。尽管在前面的例子中使用的是byte数值，但是相同的基本原则被应用于Java中的所有整数类型。

因为Java使用2的补码存储负数，并且因为Java中的所有整数都是有符号数值，所以应用位运算符时很有可能会产生意外的结果。例如，不管是有意的还是无意的，将高阶位改为1，都会导致结果值被解释为负数。为了避免产生不愉快的结果，只需要记住高阶位决定了整数的符号，而不管高阶位是如何设置的。


### 4.2.1 位逻辑运算符

位逻辑运算符包括&、|、^和~。表4-3显示了各种位逻辑运算的结果。在后续的讨论中，请牢记位运算符是针对操作数中的每个位进行操作的。























































# [README](../README.md "回到 README")