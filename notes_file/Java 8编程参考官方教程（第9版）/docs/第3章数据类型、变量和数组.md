
# [README](../README.md "回到 README")

本章分析**Java中最基本的3个元素：数据类型、变量与数组**。与所有现代编程语言一样，Java支持好几种类型的数据。可以使用这些类型声明变量并创建数组。正如你将会看到的，Java支持这些元素的方式是清晰、高效并且内聚的。

## 3.1 Java是强类型化的语言

**Java是一种强类型化的语言**，在开始时指出这一点是很重要的。实际上，**Java的安全性和健壮性正式部分来自这一事实**。强类型化意味着什么呢？首先，**每个变量具有一种类型，每个表达式具有一种类型**，并且每种类型都是严格定义的。其次，**所有赋值，不管是显式的还是在方法调用中通过参数传递的，都要进行类型兼容性检查**。在有些语言中，则不对存在冲突的类型进行自动强制转换。Java编译器检查所有表达式和参数，以确保类型是兼容的。任何类型不匹配都是错误，在编译器完成类的编译之前必须改正这些错误。


## 3.2 基本类型

Java定义了**8种基本数据类型：byte、short、int、long、char、float、double和boolean**。基本类型通常也称为简单类型，并且在本书中这两个术语都会使用。这些类型可以被分成4组：
* 整型 这一组包括byte、short、int和long，它们用于表示有符号整数。
* 浮点型 这一组包括float和double，它们表示带小数位的数字。
* 字符型 这一组包括char，表示字符集中的符号，比如字母和数字。
* 布尔型 这一组包括boolean，是一种用于表示true/false值的特殊类型。

可以直接使用这些类型，也可以使用它们构造数组以及自定义类型。因此，它们形成了所有可以创建的其他类型的基础。
    
**基本类型表示单个值——而不是复杂对象**。尽管Java在其他方面是完全面向对象的，但是基本类型不是面向对象的。它们与大多数其他非面向对象语言中的简单类型类似。这样设计的**原因是效率**。将基本类型设计成对象会极大地降低性能。

**基本类型被定义为具有明确的范围和数学行为**。**C和C++这类语言允许整数的大小随着执行环境的要求而变化**。然而，Java与之不同。因为Java需要具备可移植性，所有数据类型都具有严格定义的范围。例如，**无论在哪种特定平台上，int总是32位的，因而可以编写出不经修改就能确保在任何体系结构的计算机上都能运行的程序**。虽然严格指定整数的范围在某些环境中可能会造成一些性能损失，但为了实现可移植性这么做是必要的。
    
下面依次分析每种数据类型。


## 3.3 整型

Java定义了4种整数类型：byte、short、int和long。所有这些类型都是有符号的、正的或负的整数。**Java不支持无符号的、只是正值的整数**。许多其他计算机语言同时支持有符号和无符号整数。然而，Java的设计者觉得无符号整数不是必需的。特别是，他们觉得“无符号”的概念通常用于指定“高阶位”（high-order bit）的行为，**高阶位用于定义整型值的符号**。在第4章将会看到，Java通过添加特殊的“无符号右移”运算符，以稍微不同的方式管理高阶位的含义。因此，Java消除了对无符号整数类型的需要。

**不应将整数类型的宽度看成整数所消耗的内存量，而应该理解成定义这种类型的变量和表达式的行为**。**Java运行时环境可以自由使用它们希望的、任何大小的空间，只要类型的行为符合声明它们时的约定即可**。这些整数类型的宽度和范围相差很大，如表3-1所示。
![](images/3.3.1.png)


### 3.3.1 byte

最小的整数类型是byte。它是有符号的8位类型，范围为-128~127。当**操作来自网络或文件的数据流时，byte类型的变量特别有用**。当**操作与Java的其他内置类型不直接兼容的原始二进制数据时，byte类型的变量也很有用**。

字节变量是通过关键字byte声明的。例如，下面声明了两个byte变量b和c：  
> byte b, c;


### 3.3.2 short

short是有符号的16位类型。它的范围为-32 768~32 767。它可能是最不常用的Java类型。下面是声明short变量的一些例子：
> short s;  
> short t;


### 3.3.3 int
    
**最常用的整数类型是int。它是有符号的32位类型**，范围为-2147483648~2147483647。除了其他用途外，int类型变量通常用于控制循环和索引数组。对于那些不需要更大范围的int类型数值的情况，您可能会认为使用范围更小的byte和short类型效率更高，然而事实并非如此。原因是如果在表达式中使用byte和short值，当对**表达式求值时它们会被提升（promote）为int类型**（类型提升将在本章后面描述）。所以，当**需要使用整数时，int通常是最好的选择**。


### 3.3.4 long

**long是有符号的64位类型，对于那些int类型不足以容纳期望数值的情况**，long类型是有用的。long类型的范围相当大，这使得当需要很大的整数时它非常有用。例如，下面的程序计算光在指定的天数中传播的距离（以英里为单位）：
![](images/3.3.4.1.png)

这个程序产生的输出如下所示：
![](images/3.3.4.2.png)

显然，int变量无法保存这么大的结果。


## 3.4 浮点数

**浮点数也称为实数（real number）**，当计算需要小数精度的表达式时使用。例如，求平方根这类计算以及弦和余弦这类**超越数**，保存结果就需要使用浮点类型。Java实现了IEEE-754标准集的浮点类型和运算符。有两种浮点类型——**float和double，它们分别表示单精度和双精度浮点数**。它们的宽度和范围如表3-2所示。
![](images/3.4.1.png)


### 3.4.1 float

**float类型表示使用32为存储的单精度（single-precision）数值。在某些处理器上，单精度运算速度更快，并且占用的空间是双进度的一半，但是当数值非常大或非常小时会变得不精确**。如果需要小数部分，并且精度要求不是很高时，float类型的变量是很有用的。例如，表示美元和美分时可以使用float类型。

下面是声明float变量的一些例子：
> float hightemp,lowtemp;


### 3.4.2 double

双进度**使用double关键字表示，并使用64位存储数值。在针对高速数学运算进行了优化的某些现代处理器上，实际上双精度数值的运算速度更快**。所有超越数学函数，如sin()、cos()和sqrt()，都返回双精度值。**如果需要在很多次迭代运算中保持精度，或者操作非常大的数值，double类型是最佳选择**。

下面的简短程序使用double变量计算圆的面积：
![](images/3.4.2.1.png)
    

## 3.5 字符型

在**Java中，用于存储字符的数据类型是char**。然而，C/C++程序员要当心：Java中的char与C或C++中的char是不同的。在C/C++中，char的宽度是8位。而在Java中不是这样。相反，**Java使用Unicode表示字符**。Unicode定义了一个完全国际化的字符集，能够表示全部人类语言中的所有字符。Unicode是数十种字符集的统一体，比如拉丁字符集、希腊字符集、阿拉伯字符集、斯拉夫语字符集、希伯来语字符集、日文字符集、韩文字符集等。为此，Unicode需要16位宽。因此，在**Java中char是16位类型**。char的范围为0~65 536。没有负的char值。ASCII标准字符集的范围仍然是0~127；而扩展的8位字符集ISO-Latin-1，其范围是0~255。既然，Java的设计初衷是允许程序员编写在世界范围内均可使用的程序，那么使用Unicode表示字符是合理的。当然，对于英文、德语、西班牙语或法语这类语言，使用unicode在一定程度上会降低效率，因为可以很容易地使用8位表示这类语言的字符。但这是为了在全球获得可移植性而必须付出的代价。

**注意：**
> 在http//www.unicode.org上可以找到有关Unicode的更多信息。
    
下面是演示char变量用法的一个程序：
![](images/3.5.1.png)
注意，**ch1被赋值为88，该值是与字母X对应的ASCII（以及Unicode）值**。前面提到过，ASCII字符集占用Unicode字符集中的前127个值。因此，在其他语言中对字符使用的所有“旧式技巧”，在Java中仍然管用。
    
尽管**char被设计成容纳Unicode字符，但它也可以用作整数类型，可以对char类型的变量执行算数运算**。例如，可以将两个字符相加到一起，或者增加字符变量的值。分析下面的程序：
![](images/3.5.2.png)
在该程序中，首先将X赋给ch1，然后递增ch1的值。现在ch1中包含的结果Y，是ASCII（以及Unicode）序列中的下一个字符。

**注意：**
> 在Java的正式规范中，char被当作整数类型，这意味着它和int、short、long以及byte位于同一分类中。然而，因为char类型的主要用途是表示Unicode字符，所以通常考虑将char放到单独的分类中。


## 3.6 布尔型

Java有一种称为**boolean的基本类型，用于表示逻辑值**。它只能是两个可能的值之一：**true或false。所有关系元素（例如a<b）都返回这种类型的值**。对于if和for这类控制语句的条件表达式，也需要boolean类型。
下面的程序演示了boolean类型：
![](images/3.6.1.png)

关于这个程序有三个有趣的地方需要注意。首先可以看出，当通过println()方法输出boolean值时，显示的是true或false。其次，对于控制语句if来说，boolean变量的值本身是足够的。不需要像下面这样编写if语句：
![](images/3.6.2.png)

最后，关系运算符（例如<）的输出是boolean值。这就是为什么表达式10>9显示true的原因。此外，10>9周围的圆括号是必需的，因为**运算符+比>具有更高的优先级**。


## 3.7 深入分析字面值

在第2章已经简要提及了字面值。前面已经正式描述了内置类型，接下来深入分析字面值。


### 3.7.1 整型字面值

在典型的程序中，整型可能是最常用的类型。**所有整数值都是整型字面值**，例如1、2、3和42。这些都是十进制数字，表示它们是以10为基数描述的。在整型字面值中，还可以使用另外两种进制——八进制（以8为基数）和十六进制（以16为基数）。**在Java中，八进制数值以0开头**。常规的十进制数字不以0开头。因此，对于看似有效的值09,编译器会产生一个错误，因为9超出了八进制数字0~7的范围。程序员针对数字更常使用的是十六进制，以便整齐地匹配以8为模的字的尺寸，如8位、16位、32位和64位。**以0x或0X开头来标识十六进制常量**。十六进制数字的范围是0~15，因此分别**用A~F（或a~f）替代数字10~15**。

**整型字面值用于创建int类型整数值**，在Java中是**32位的整数**。既然Java是强类型化的，您可能会好奇Java如何将整型字面值赋给其他整数类型，如byte或long，而不会导致类型不匹配错误。幸运的是这种情况很容易处理。当将字面值赋给byte或short变量时，如果字面值位于目标类型的范围之内，就不会产生错误。整型字面值总是可以赋给long变量。然而，为了标识long字面值，需要明确告诉编译器字面值是long类型的。可以通过为字面值附加一个大写或小写的L来明确地标识其类型为long，例如0x7ffffffffffffffL 或 9223372036854775807L是最大的long类型的字面值。也可以将整数赋给char，只要char类型的范围之内即可。

从JDK 7开始，可以使用**二进制指定整型字面值。为此，使用0b或0B作为数值的前缀**。例如，下面这行代码使用二进制字面值指定十进制值10：
![](images/3.7.1.1.png)

除了其他用途之外，**二进制字面值简化了用作位掩码的数值的输入**。对于这种情况，十进制（或十六进制）表示的数值不能很直观地表达出与其他用途相关的含义，而二进制字面值却可以。

从JDK 7开始，在整型字面值中还可以嵌入一个或多个下划线。嵌入下划线可以使阅读很大的整数变得更加容易。当编译字面值时，会丢弃下划线。例如，下面这行代码：
![](images/3.7.1.2.png)

为x提供的值为123 456 789，下划线将被忽略。**下划线只能用于分割数字，不能位于字面值的开头和结尾**。然而，在**两个数字之间使用多个下划线是允许的**。例如，下面这行代码是合法的：
![](images/3.7.1.3.png)

**当编码电话号码、消费者ID号、零件编码等事物时，在整型字面值中使用下划线特别有用**。当指定二进制字面值时，下划线对于提供视觉分组也是有用的。例如，二进制数值经常以4位进行视觉分组，如下所示：
![](images/3.7.1.4.png)


### 3.7.2 浮点型字面值

**浮点数表示具有小数部分的十进制数值**。可以使用标准计数法或科学计数法表示浮点数。**标准计数法由前面的整数部分、其后的小数点以及小数点后面的小数部分构成**。例如，2.0、3.1419以及0.6667都表示有效的标准计数法浮点数。**科学计数法使用一个由标准计数法表示的浮点数加上一个后缀表示，其中的后缀指定为10的幂，它与前面的浮点数是相乘的关系**。**指数部分用E（或e）**后面跟上一个十进制数表示，该十进制数可以是正数，也可以是负数，例如6.022E23、314159E-05以及2e+100。

在Java中，**浮点型字面值默认是双精度的**。为了指定浮点型字面值，必须为常量附加一个F或f。也可以通过附加D或d来显式地指定double字面值。当然，这么做是多余的。默认的double类型使用64位存储，而更小的float类型只需要32位。

**Java也支持十六进制浮点型字面量**，但是很少使用。它们必须使用与科学计数法类似的形式来表示，不过**使用的是P或p**，而不是E或e。例如，0x12.2p2是一个有效的浮点型字面值。**P后面的数值称为二进制指数，表示2的幂，并且和前面的数字相乘**。所以，0x12.2P2代表72.5。
    
从JDK 7开始，在**浮点型字面值中可以嵌入一个或多个下划线**。该特性和用于整型字面值时的工作方式相同，刚才已经介绍过。这一特性的目的是使阅读很大的浮点型字母值更加容易。**当编译字面值时，会丢弃下划线**。例如，下面这行代码：
![](images/3.7.2.1.png)
将变量num赋值为9 432 497 862.0，下划线会被忽略。与整型字面值一样，下划线只能用于分割数字。它们不能位于字面值的开头或结尾。然而，在两个数值之间使用多个下划线是允许的。在小数部分中也可以使用下划线，例如：
![](images/3.7.2.2.png)


### 3.7.3 布尔型字面值

布尔型字面值很简单。**布尔型只有两个逻辑值——true和false。true和false不能转换成任何数字表示形式**。在Java中，字面值true不等于1,字面值false也不等于0。在Java中，只能将布尔型字面值赋给以布尔型声明的变量，或用于使用布尔值运算符的表达式中。


### 3.7.4 字符型字面值

Java中的字符被索引到Unicode字符集，它们是可以转换成整数的16位值，并且可以使用整数运算符进行操作，例如加和减运算符。**字符型字面值使用位于一对单引号中的字符来表示**。所有可见的ASCII字符都可以直接输入到单引号中，如'a'、'z'以及'@'。对于那些不能直接输入的字符，可以使用转义字符序列输入需要的字符，**例如'\''表示单引号、'\n'表示换行符**。还有一种以八进制或十六进制直接输入字符值的机制。对于八进制表示法，使用反斜杠后跟三位数字表示，例如'\141'是字母'a'。对于十六进制，先输入'\u'，然后是4为的十六进制数。例如'\u0061'表示ISO-Lation-1字符'a'，因为第一个字符为0；'\ua432'是一个Japaness Katakana字符。表3-3显示了字符转义序列。
![](images/3.7.4.1.png)


### 3.7.5 字符串字面值

在Java中，**指定字符串字面值的方法与其他大多数语言相同——使用位于一对双引号中的字符序列**。下面是字符串字面值的几个例子：
![](images/3.7.5.1.png)

为字符型字面值定义的转义序列和八进制/十六进制表示法，在字符串字面值中同样适用。关于**Java字符串需要重点指出的是，它们的开头和结尾必须位于同一行中。与其他某些语言不同，在Java中没有续行的转义序列**。

注意：
> 你可能知道，在其他某些语言中，包括C/C++，**字符串是作为字符数组实现的**。然而，在Java中不是如此。在Java中，字符串**实际上是对象类型**。在本书的后面将会看到，因为Java将字符串作为对象实现，所以提供了广泛的、功能强大且易于使用的字符串处理功能。


## 3.8 变量

在Java程序中，变量是基本存储单元。变量是通过联合标识符、类型以及可选的初始化器来定义的。此外，所有的变量都有作用域，作用域定义了变量的可见性和生存期。下面分析分析这些元素。





























# [README](../README.md "回到 README")