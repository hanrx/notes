# [README](../README.md "回到 README")

# 第1章 深入Web请求过程

随着Web 2.0时代的到来，互联网的网络架构已经从传统的C/S架构转变为更加方便、快捷的B/S架构，B/S架构大大简化了用户使用网络应用的难度，这种人人都能上网、人人都能使用网络上提供的服务的方法也进一步推动了互联网的繁荣。

B/S架构带来了以下两方面的好处。
* 客户端使用通用的浏览器（Browser）。由于浏览器具有统一性，它不需要特殊的配置和网络连接，有效地**屏蔽了不同服务提供商提供给用户使用服务的差异性**。另外，最重要的一点是，浏览器的交互特性使得用户使用它非常方便，且**用户行为的可继承性非常强**，也就是用户只要学会了上网，不管使用的哪个应用，一旦学会了，在使用其他互联网服务时同样具有了使用经验，因为他们都具有同样的浏览器操作界面。
* 服务端（Server）基于统一的HTTP。和传统的C/S架构使用自定义的应用层协议不同，B/S架构使用的都是统一的HTTP。**使用统一的HTTP也为服务提供商简化了开发模式**，使得服务器开发者可以采用相对规范的开发模式，这样可以大大节省开发成本。由于使用统一的HTTP，所以基于HTTP的服务器就有很多，如**Apache、IIS、Nginx、Tomcat、JBoss等**，这些服务器可以直接拿来使用，不需要服务器开发者单独来开发。不仅如此，连开发服务的通用框架都不需要单独开发，服务开发者只需要关注提供服务的应用逻辑，其他一切平台和框架都可以直接拿来使用，所以B/S框架同样简化了服务器提供者的开发，从而出现了越来越多的互联网服务。

B/S网络结构不管对普通用户的使用还是对服务的开发都带来了好处，为互联网的主要参与者、服务使用者和服务开发者降低了学习成本。但是作为互联网应用的开发者，我们还是要清楚，从用户在浏览器里单击某个链接开始，到我们的服务返回结果给浏览器为止，在这个过程中到底发生了什么、这其中还需要哪些技术来配合。

所以本章将为你描述这一过程的工作原理，它**将涉及浏览器的基本行为和HTTP的解析过程、DNS如何解析到对应的IP地址、CDN又是如何工作和设计的，以及浏览器如何渲染出返回的结果等**。

## 1.1 B/S网络架构概述

B/S网络架构从前端到后端都得到了简化，都基于统一的应用层协议HTTP来交互数据，**与大多数传统C/S互联网应用程序采用的长连接的交互模式不同，HTTP采用无状态的短链接的通信方式**，通常情况下，一次请求就完成了一次数据交互，通常也对应一个业务逻辑，然后这次通信连接就断开了。采用这种方式是为了能够同时服务更多的用户，因为当前互联网应用每天都会处理上亿的用户请求，不可能每个用户访问一次后就一直保持这个连接。
    
基于HTTP本身的特点，目前B/S网络架构大多采用如图1-1所示的架构设计，既要满足海量用户的访问请求，又要保持用户请求的快速响应，所以现在的网络架构也越来越复杂。

当一个用户在浏览器里输入www.taobao.com这个URL时，将会发生很多操作。首先**它会请求DNS把这个域名解析成对应的IP地址，然后根据这个IP地址在互联网上找到对应的服务器，向这个服务器发起一个get请求，由这个服务器决定返回默认的数据资源给访问的用户。在服务器端实际上还有很复杂的业务逻辑：服务器可能有很多台，到底指定哪台服务器来处理请求，这需要一个负载均衡设备来平均分配所有用户的请求；还有请求的数据是存储在分布式缓存里还是一个静态文件中，或是在数据库里；当数据返回浏览器时，浏览器解析数据发现还有一些静态资源（如CSS、JS或者图片）时又会发起另外的HTTP请求，而这些请求很可能会在CDN上，那么CDN服务器又会处理这个用户的请求，大体上一个用户请求会涉及这么多的操作**。每一个细节都会影响这个请求最终是否会成功。
![](images/1.1.1.png)
![](images/1.1.2.png)

不管网络结构如何变化，始终有一些固定不变的原则需要遵守。
* **互联网上所有资源都要用一个URL来表示**。URL就是统一资源定位符，如果你要发布一个服务或者一个资源到互联网上，让别人能够访问到，那么你首先必须要有一个在世界上独一无二的URL。不要小看这个URL，它几乎包含了整个互联网的架构精髓。
* 必须**基于HTTP与服务端交互**。不管你要访问的是国内的还是国外的数据，是文本数据还是流媒体，都必须按照套路出牌，也就是都得采用统一打招呼的方式，这样人家才会明白你要的是什么。
* **数据展示必须在浏览器中进行**。当你获取到数据资源后，必须在浏览器上才能恢复它的容貌。

只要满足上面的几点，一个互联网应用基本上就能正确地运转起来，当然这里面还有好多细节，这些细节在后面将分别进行详细讲解。

## 1.2 如何发起一个请求

如何发起一个HTTP请求？这个问题似乎既简单又复杂，简单是指当你在浏览器里输入一个URL时，按回车键后这个HTTP请求就发起了，很快你就会看到这个请求的返回结果。复杂是指能否不借助浏览器也能发起请求，这里的“不借助”有两层含义，一是指能不能自己组装一个符合HTTP的数据包，二是除了浏览器还有哪些方式也能简单地发起一个HTTP请求。下面就按照这两层含义来解释如何发起一个HTTP请求。

**如何发起一个HTTP请求和如何建立一个Socket连接区别不大，只不过outputStream.write写的二进制数据格式要符合HTTP**。浏览器在建立Socket连接之前，必须根据地址栏里输入的URL的域名DNS解析出IP地址，再根据这个IP地址和默认的80端口与远程服务器建立Socket连接，然后浏览器根据这个URL组装成一个get类型的HTTP请求头，通过outputStream.write发送到目标服务器，服务器等待inputStream.read返回数据，最后断开这个连接。

当然，不同浏览器在如何使用这个已经建立好的连接以及根据什么规则来管理连接上，有各种不同的实现方法。一句话，发起一个HTTP请求的过程就是建立一个Socket通信的过程。
    
既然发起一个HTTP连接的本质上就是建立一个Socket连接，那么我们完全可以模拟浏览器来发起HTTP请求，这很好实现，也有很多方法实现，如HttpClient就是一个开源的通过程序实现的处理HTTP请求的工具包。当然如果你对HTTP的数据结构非常熟悉，你完全可以自己再实现另外一个HTTPClient，甚至可以自己写个简单的浏览器。

下面是一个基本的HttpClient的调用示例：
![](images/1.2.1.png)

处理Java中使用非常普遍的HttpClient还有很多类似的工具，如Linux中的curl命令，通过curl + URL就可以简单地发起一个HTTP请求，非常方便。
    
例如，curl "http://item.taobao.com/item.html?id=1264"可以返回这个页面的HTML数据，如图1-2所示。
![](images/1.2.2.png)

也可以查看这次访问的HTTP头的信息，加上-I选项，如图1-3所示。
![](images/1.2.3.png)

还可以在访问这个URL时增加HTTP头，通过-HI选项实现，如图1-4所示。
![](images/1.2.4.png)

因为缺少Cookie信息，所以上面的访问返回302状态码，必须增加Cookie才能正确访问该链接，如下所示：
![](images/1.2.5.png)

## 1.3 HTTP解析













# [README](../README.md "回到 README")