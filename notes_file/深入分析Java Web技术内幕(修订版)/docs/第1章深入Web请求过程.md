# [README](../README.md "回到 README")

# 第1章 深入Web请求过程

随着Web 2.0时代的到来，互联网的网络架构已经从传统的C/S架构转变为更加方便、快捷的B/S架构，B/S架构大大简化了用户使用网络应用的难度，这种人人都能上网、人人都能使用网络上提供的服务的方法也进一步推动了互联网的繁荣。

B/S架构带来了以下两方面的好处。
* 客户端使用通用的浏览器（Browser）。由于浏览器具有统一性，它不需要特殊的配置和网络连接，有效地**屏蔽了不同服务提供商提供给用户使用服务的差异性**。另外，最重要的一点是，浏览器的交互特性使得用户使用它非常方便，且**用户行为的可继承性非常强**，也就是用户只要学会了上网，不管使用的哪个应用，一旦学会了，在使用其他互联网服务时同样具有了使用经验，因为他们都具有同样的浏览器操作界面。
* 服务端（Server）基于统一的HTTP。和传统的C/S架构使用自定义的应用层协议不同，B/S架构使用的都是统一的HTTP。**使用统一的HTTP也为服务提供商简化了开发模式**，使得服务器开发者可以采用相对规范的开发模式，这样可以大大节省开发成本。由于使用统一的HTTP，所以基于HTTP的服务器就有很多，如**Apache、IIS、Nginx、Tomcat、JBoss等**，这些服务器可以直接拿来使用，不需要服务器开发者单独来开发。不仅如此，连开发服务的通用框架都不需要单独开发，服务开发者只需要关注提供服务的应用逻辑，其他一切平台和框架都可以直接拿来使用，所以B/S框架同样简化了服务器提供者的开发，从而出现了越来越多的互联网服务。

B/S网络结构不管对普通用户的使用还是对服务的开发都带来了好处，为互联网的主要参与者、服务使用者和服务开发者降低了学习成本。但是作为互联网应用的开发者，我们还是要清楚，从用户在浏览器里单击某个链接开始，到我们的服务返回结果给浏览器为止，在这个过程中到底发生了什么、这其中还需要哪些技术来配合。

所以本章将为你描述这一过程的工作原理，它**将涉及浏览器的基本行为和HTTP的解析过程、DNS如何解析到对应的IP地址、CDN又是如何工作和设计的，以及浏览器如何渲染出返回的结果等**。

## 1.1 B/S网络架构概述

B/S网络架构从前端到后端都得到了简化，都基于统一的应用层协议HTTP来交互数据，**与大多数传统C/S互联网应用程序采用的长连接的交互模式不同，HTTP采用无状态的短链接的通信方式**，通常情况下，一次请求就完成了一次数据交互，通常也对应一个业务逻辑，然后这次通信连接就断开了。采用这种方式是为了能够同时服务更多的用户，因为当前互联网应用每天都会处理上亿的用户请求，不可能每个用户访问一次后就一直保持这个连接。
    
基于HTTP本身的特点，目前B/S网络架构大多采用如图1-1所示的架构设计，既要满足海量用户的访问请求，又要保持用户请求的快速响应，所以现在的网络架构也越来越复杂。

当一个用户在浏览器里输入www.taobao.com这个URL时，将会发生很多操作。首先**它会请求DNS把这个域名解析成对应的IP地址，然后根据这个IP地址在互联网上找到对应的服务器，向这个服务器发起一个get请求，由这个服务器决定返回默认的数据资源给访问的用户。在服务器端实际上还有很复杂的业务逻辑：服务器可能有很多台，到底指定哪台服务器来处理请求，这需要一个负载均衡设备来平均分配所有用户的请求；还有请求的数据是存储在分布式缓存里还是一个静态文件中，或是在数据库里；当数据返回浏览器时，浏览器解析数据发现还有一些静态资源（如CSS、JS或者图片）时又会发起另外的HTTP请求，而这些请求很可能会在CDN上，那么CDN服务器又会处理这个用户的请求，大体上一个用户请求会涉及这么多的操作**。每一个细节都会影响这个请求最终是否会成功。
![](images/1.1.1.png)
![](images/1.1.2.png)

不管网络结构如何变化，始终有一些固定不变的原则需要遵守。
* **互联网上所有资源都要用一个URL来表示**。URL就是统一资源定位符，如果你要发布一个服务或者一个资源到互联网上，让别人能够访问到，那么你首先必须要有一个在世界上独一无二的URL。不要小看这个URL，它几乎包含了整个互联网的架构精髓。
* 必须**基于HTTP与服务端交互**。不管你要访问的是国内的还是国外的数据，是文本数据还是流媒体，都必须按照套路出牌，也就是都得采用统一打招呼的方式，这样人家才会明白你要的是什么。
* **数据展示必须在浏览器中进行**。当你获取到数据资源后，必须在浏览器上才能恢复它的容貌。

只要满足上面的几点，一个互联网应用基本上就能正确地运转起来，当然这里面还有好多细节，这些细节在后面将分别进行详细讲解。

## 1.2 如何发起一个请求

如何发起一个HTTP请求？这个问题似乎既简单又复杂，简单是指当你在浏览器里输入一个URL时，按回车键后这个HTTP请求就发起了，很快你就会看到这个请求的返回结果。复杂是指能否不借助浏览器也能发起请求，这里的“不借助”有两层含义，一是指能不能自己组装一个符合HTTP的数据包，二是除了浏览器还有哪些方式也能简单地发起一个HTTP请求。下面就按照这两层含义来解释如何发起一个HTTP请求。

**如何发起一个HTTP请求和如何建立一个Socket连接区别不大，只不过outputStream.write写的二进制数据格式要符合HTTP**。浏览器在建立Socket连接之前，必须根据地址栏里输入的URL的域名DNS解析出IP地址，再根据这个IP地址和默认的80端口与远程服务器建立Socket连接，然后浏览器根据这个URL组装成一个get类型的HTTP请求头，通过outputStream.write发送到目标服务器，服务器等待inputStream.read返回数据，最后断开这个连接。

当然，不同浏览器在如何使用这个已经建立好的连接以及根据什么规则来管理连接上，有各种不同的实现方法。一句话，发起一个HTTP请求的过程就是建立一个Socket通信的过程。
    
既然发起一个HTTP连接的本质上就是建立一个Socket连接，那么我们完全可以模拟浏览器来发起HTTP请求，这很好实现，也有很多方法实现，如HttpClient就是一个开源的通过程序实现的处理HTTP请求的工具包。当然如果你对HTTP的数据结构非常熟悉，你完全可以自己再实现另外一个HTTPClient，甚至可以自己写个简单的浏览器。

下面是一个基本的HttpClient的调用示例：
![](images/1.2.1.png)

处理Java中使用非常普遍的HttpClient还有很多类似的工具，如Linux中的curl命令，通过curl + URL就可以简单地发起一个HTTP请求，非常方便。
    
例如，curl "http://item.taobao.com/item.html?id=1264"可以返回这个页面的HTML数据，如图1-2所示。
![](images/1.2.2.png)

也可以查看这次访问的HTTP头的信息，加上-I选项，如图1-3所示。
![](images/1.2.3.png)

还可以在访问这个URL时增加HTTP头，通过-HI选项实现，如图1-4所示。
![](images/1.2.4.png)

因为缺少Cookie信息，所以上面的访问返回302状态码，必须增加Cookie才能正确访问该链接，如下所示：
![](images/1.2.5.png)

## 1.3 HTTP解析

B/S网络结构的核心是HTTP，掌握HTTP对一个从事互联网工作的程序员来说非常重要，也许你已经非常熟悉HTTP，这里除了简单介绍HTTP的基本知识外，还将侧重介绍实际使用的一些心得，后面以实际使用的场景为例进行介绍。

要理解HTTP，最重要的就是要熟悉HTTP中的HTTP Header，**HTTP Header控制着互联网上成千上万的用户的数据的传输。最关键的是，它控制着用户浏览器的渲染行为和服务器的执行逻辑**。例如，当服务器没有用户请求的数据时就会返回一个404状态码，告诉浏览器没有要请求的数据，通常浏览器就会展示一个非常不愿意看到的该页面不存在的错误信息。

常见的HTTP请求头和响应头分别如表1-1和表1-2所示，常见的HTTP状态码如表1-3所示。
![](images/1.3.1.png)
![](images/1.3.2.png)

要看一个HTTP请求的请求头和响应头，可以通过很多浏览器插件来看，在Firefox中有Firebug和HttpFox，Chrome自带的开发工具也可以看到每个请求的请求头信息（可用F12快捷键打开），IE自带的调试工具也有类似的功能。


### 1.3.1 查看HTTP信息的工具

有时候我们需要知道一个HTTP请求到底返回什么数据，或者没有返回数据时想知道是什么原因造成的，这时我们就需要借助一些工具来查询这次请求的详细信息。

在Windows下现在主流的浏览器都有很多工具来查看当前请求的详细HTTP信息，如Firefox浏览器下，使用最多的是Firebug，如图1-5所示。
![](images/1.3.1.1.png)

还有一个HttpFox工具提供的信息更全，如图1-6所示，所有HTTP相关信息都可以一目了然。
![](images/1.3.1.2.png)

Chrome浏览器下也有一些类似的工具，如Google自带的调试工具，同样可以查看到这次请求的相关信息，如图1-7所示。
![](images/1.3.1.3.png)

Chrome下也有类似的Firebug工具，但是还不够完善。
    
IE从7.0版本开始也提供了类似的HTTP调试工具，如自带的开发人员工具可以通过F12键打开，HttpFox插件也有IE版本，读者可以试着安装一下。

### 1.3.2 浏览器缓存机制

浏览器缓存是一个比较复杂但是又比较重要的机制，在我们浏览一个页面时发现有异常的情况下，通常考虑的就是是不是浏览器做了缓存，所以一般的做法是**按Ctrl+F5组合键重新请求一次这个页面，重新请求的页面肯定是最新的页面**。为什么重新请求就一定能够请求到没有缓存的页面呢？首先是在浏览器端，如果是**按Ctrl+F5组合键刷新页面，那么浏览器会直接向目标URL发送请求**，而不会使用浏览器缓存的数据；其次**即使请求发送到服务端，也有可能访问到的是缓存的数据，比如，在我们的应用服务器的前端部署一个缓存服务器**，如Varnish代理，那么Varnish也可能直接使用缓存数据。所以为了保证用户能够看到最新的数据，必须通过HTTP来控制。
    
当我们使用Ctrl+F5组合键刷新一个页面时，**在HTTP的请求头中会增加一些请求头，它告诉服务端我们要获取最新的数据而不是缓存**。

如图1-8所示，这次请求没有发送到服务端，使用的是浏览器的缓存数据，按Ctrl+F5组合键刷新后，如图1-9所示。
![](images/1.3.2.1.png)
![](images/1.3.2.2.png)

这次请求时从服务端返回的数据，最重要的是在其请求头中增加了**两个请求项Pragma:no-cache和Cache-Control:no-cache**。为什么增加了这两项配置项，它们有什么作用？

#### 1.Cache-Control/Pragma

这个**HTTP Head字段用于指定所有缓存机制在整个请求/响应链中必须服从的指令**，如果知道该页面是否为缓存，不仅可以控制浏览器，还可以控制和HTTP相关的缓存或代理服务器。HTTP Head字段有一些可选值，这些值及其说明如表1-4所示。
![](images/1.3.2.3.png)

**Cache-Control请求字段被各个浏览器支持的较好，而且它的优先级也比较高，它和其他一些请求字段（如Expires）同时出现时，Cache-Control会覆盖其他字段**。
    
**Pragma字段的作用和Cache-Control有点类似**，它也是在HTTP头中包含一个特殊的指令，使相关的服务遵守该指令，最常用的就是Pragma:no-cache，它和Cache-Control:no-cache的作用是一样的。

#### 2. Expires

Expires通常的使用格式是Expires: Sat, 25 Feb 2012 12:22:17 GMT，后面跟着一个日期和时间，**超过这个时间值后，缓存的内容将失效**，也就是浏览器在发出请求之前检查这个页面的这个字段，看该页面是否已经过期了，过期了就重新向服务器发起请求。

#### 3. Last-Modified/Etag

**Last-Modified字段一般用于表示一个服务器上的资源的最后修改时间，资源可以是静态（静态内容自动加上Last-Modified字段）或者动态的内容（如Servlet提供了一个getLaseModified方法检测某个动态内容是否已经更新）**，通过这个最后修改时间可以判断当前请求的资源是否是最新的。

**一般服务端在响应头中返回一个Last-Modified字段，告诉浏览器这个页面的最后修改时间，如Lase-Modified：Sat,25 Feb 2012 12:55:04 GMT，浏览器再次请求时在请求头中增加一个If-Modified-Since: Sat,25 Feb 2012 12:55:04 GMT字段，询问当前缓存的页面是否是最新的，如果是最新的就返回304状态码，告诉浏览器是最新的，服务器也不会传输新的数据**。

**与Last-Modified字段有类似功能的还有一个Etag字段**，这个字段的作用是让服务器端给每个页面分配一个唯一的编号，然后通过这个编号来区分当前这个页面是否是最新的。这种方式比使用Last-Modified更加灵活，但是在后端的Web服务器有多台时比较难以处理，因为每个Web服务器都要记住网站的所有资源，否则浏览器返回这个编号就没有意义了。


## 1.4 DNS域名解析

我们知道互联网都是通过URL来发布和请求资源的，而URL中的域名需要解析成IP地址才能与远程主机建立连接，如何将域名解析成IP地址属于DNS解析的工作范畴。

可以毫不夸张地说，虽然我们平时上网感觉不到DNS的解析的存在，但是一旦DNS解析出错，可能会导致非常严重的互联网灾难。目前世界上的整个互联网有几个DNS根域名服务器，任何一台根服务器坏掉，后果都非常严重。

### 1.4.1 DNS域名解析过程

![](images/1.4.1.1.png)
![](images/1.4.1.2.png)
图1-10是DNS域名解析的主要请求过程实例图。

如图1-10所示，当一个用户在浏览器中输入www.abc.com时，DNS解析将会有将近10个步骤，这个过程大体描述如下。

当用户在浏览器中输入域名并按下回车键后，第1步，**浏览器会检查缓存中**有没有这个域名对应的解析过的IP地址，如果缓存中有，这个解析过程就将结束。浏览器缓存域名也是有限制的，不仅浏览器缓存大小有限制，而且缓存的时间也有限制，通常情况下为几分钟到几个小时不等，域名被缓存的时间限制可以通过TTL属性来设置。这个缓存时间太长和太短都不好，如果缓存时间太长，一旦域名解析到IP有变化，会导致被客户端缓存的域名无法解析到变化后的IP地址，以致域名不能正常解析，这段时间内有可能会有一部分用户无法访问网站。如果时间设置太短，会导致用户每次访问网站都要重新解析一次域名。

第2步，如果用户的浏览器缓存中没有，**浏览器会查找操作系统缓存中是否有这个域名对应的DNS解析结果**。其实操作系统也会有一个域名解析的过程，在Windows中可以通过C:\Windows\System32\drivers\etc\hosts文件来设置，你可以将任何域名解析到任何能够访问的IP地址。如果你在这里指定了一个域名对应的IP地址，那么浏览器会首先使用这个IP地址。例如，我们在测试时可以将一个域名解析到一台测试服务器上，这样不用修改任何代码就能测试到单独服务器上的代码的业务逻辑是否正确。正是因为有这种本地DNS解析的规则，所以黑客就有可能通过修改你的域名解析器来把特定的域名解析到它指定的IP地址上，导致这些**域名被劫持**。

这导致在早期的Windows版本中出现过很严重的问题，而且对于一般没有太多计算机知识的用户来说，出现问题后很难发现，即使发现也很难自己解决，所以Windows 7中将hosts文件设置成了只读的，防止这个文件被轻易修改。
    
在Linux中这个配置文件是/etc/host，修改这个文件可以达到同样的目的，当解析到这个配置文件中的某个域名时，操作系统会在缓存中缓存这个解析结果，缓存的时间同样是受这个域名的失效时间和缓存的空间大小控制的。

前面这两个步骤都是在本机完成的，所以在图1-10中没有表示出来。到这里还没有涉及真正的域名解析服务器，如果在本机中仍然无法完成域名的解析，就会真正请求域名服务器来解析这个域名了。

第3步，如何、怎么知道域名服务器呢？在我们的网络配置中都会有“DNS服务器地址”这一项，这个地址就用于解决前面所说的如果两个过程无法解析时要怎么办，**操作系统会把这个域名发送给这里设置的LDNS，也就是本地区的域名服务器**。这个DNS通常都提供给你本地互联网接入的一个DNS解析服务，例如你是在学校接入互联网，那么你的DNS服务器肯定在你的学校，如果你是在一个小区接入互联网的，那这个DNS就是提供给你接入互联网的应用提供商，即典型或者联通，也就是通常所说的**SPA**，那么这个DNS通常也会在你所在城市的某个角落，通常不会很远。**在Windows下可以通过ipconfig查询这个地址**，如图1-11所示。
![](images/1.4.1.3.png)

在Linux下可以通过如下方式查询配置的DNS Server，如图1-12所示。
![](images/1.4.1.4.png)

这个专门的域名解析服务器性能都很好，它们一般都会缓存域名解析结果，当然缓存时间是受域名的失效时间控制的，一般缓存空间不是影响域名失效的主要因素。大约80%的域名解析都到这里就已经完成了，所以LDNS主要承担了域名的解析工作。

第4步，如果LDNS仍然没有命中，就**直接到ROOT Server域名服务器请求解析**。
    
第5步，**根域名服务器返回给本地域名服务器一个所查询域的主域名服务器（gTLD Server）地址**。gTLD是国际顶级域名服务器，如.com、.cn、.org等。
    
第6步，本地域名服务器（Local DNS Server）再向上一步返回的gTLD服务器发送请求。

第7步，接受请求的gTLD服务器查找并返回此域名对应的Name Server域名服务器的地址，这个Name Server通常就是你注册的域名服务器，例如你在某个域名服务提供商申请的域名，那么这个**域名解析任务就由这个域名提供商的服务器来完成**。

第8步，Name Server域名服务器会查询存储的域名和IP地址的映射关系表，**在正常情况下都根据域名得到目标IP记录，连同一个TTL值返回给DNS Server域名服务器**。

第9步，返回该域名对应的IP和TTL值，Local DNS Server会缓存这个域名和IP的对应关系，缓存的时间由TTL值控制。

第10步，把解析的结果返回给用户，用户根据TTL值缓存在本地系统缓存中，域名解析过程结束。


在实际的DNS解析过程中，可能还不止这10个步骤，如Name Server也可能有多级，或者有一个GTM来负载均衡控制，这都有可能会影响域名解析的过程。


### 1.4.2 跟踪域名解析过程







# [README](../README.md "回到 README")