


## [第8章 分布式事务](docs/第8章%20分布式事务.md "第8章 分布式事务")

* 数据库事务：作为单个逻辑工作单元执行的多个数据库操作，要么同时成功，要么同时失败，它必须满足ACID特性。
    * 原子性（Atomicity）：事务必须是原子工作单元，不可继续分割，要么全部成功，要么全部失败。
    * 一致性（Consistency）：事务完成时，所有数据都必须保持一致。
    * 隔离性（Isolation）：由于并发事务所做的修改必须与任何其他并发事务所做的修改隔离。
    * 持久性（Durability）：事务执行完成之后，它对系统的影响是永久的。

* 分布式事务：是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于分布式系统的不同节点上。
* X/Open DTP：是X/Open这个组织定义的一套分布式事务的标准。提出了使用两个阶段提交（2PC，Two-Phase-Commit）来保证分布式事务的完整性。包含以下三种角色。(TM和多个RM之间的事务控制，是基于XA协议（XA Specification）来完成的。XA协议是X/Open提出的分布式事务处理规范，也是分布式事务处理的工业标准)
    * AP：Application，表示应用程序。
    * RM：Resource Manager，表示资源管理器，比如数据库。
    * TM：Transaction Manager，表示事物管理器。

* 两个阶段提交协议：
    * 第一阶段是事务的准备阶段。
    * 第二阶段是事务的提交或者回滚阶段。
    缺点：
        * 同步阻塞：RM都是事务阻塞型的，对于任何一次指令都必须要有明确的响应才能继续进行下一步，否则就会处于阻塞状态，占用的资源一直被锁定。
        * 过于保守：任何一个节点失败都会导致数据回滚。
        * 事务协调者的单点故障：如果协调者在第二阶段出现了故障，那么其他的参与者（RM）会一直处于锁定状态。
        * “脑裂”导致数据不一致问题：在第二阶段中，事务协调者向所有参与者（RM）发送commit请求后，发生局部网络异常导致只有一部分参与者（RM）接受了commit请求，这部分参与者（RM）收到请求后会执行commit操作，但是未收到commit请求的节点由于事务无法提交，导致数据出现不一致问题。

* 三阶段提交协议：（三阶段提交协议是两阶段提交协议的改进版本，它利用**超时机制**解决了同步阻塞的问题）
    * CanCommit（询问阶段）：事务协调者向参与者发送事务执行请求，询问是否可以完成指令，参与者只需要回答是或者不是即可，不需要做真正的事务操作，这个阶段会有**超时中止机制**。
    * PreCommit（准备阶段）：事务协调者会根据参与者的反馈结果决定是否继续执行，如果在询问阶段所有参与者都返回可以执行操作，则事务协调者会向所有参与者发送PreCommit请求，参与者收到请求后写redo和undo日志，执行事务操作但是不提交事务，然后返回ACK响应等待事务协调者的下一步通知。如果在询问阶段任意参与者返回不能执行操作的结果，那么事务协调者会向所有参与者发送事务中断请求。
    * DoCommit（提交或回滚阶段）：这个阶段也会存在两种结果，仍然根据上一步骤的执行结果来决定DoCommit的执行方法。如果每个参与者在PreCommit阶段都返回成功，那么事务协调者会向所有参与者发起事务提交指令。反之，如果参与者中的任一参与者返回失败，那么事务协调者就会发起中止指令来回滚事务。
    * 三阶段提交协议和两阶段提交协议相比有一些不同点：
        * 增加了一个CanCommit阶段，用于询问所有参与者是否可以执行事务操作并且响应，它的好处是，可以**尽早发现无法执行操作而中止后续的行为**。
        * 在准备阶段之后，事务协调者和参与者都引入了超时机制。
    * 两阶段提交和三阶段提交是XA协议解决分布式数据一致性问题的基本原理，但是这**两种方案为了保证数据的强一致性，降低了可用性**。

* CAP定理和BASE理论：
    * CAP定理：又叫布鲁尔定理。简单来说它是指在分布式系统中不可能同时满足一致性（C：Consistency）、可用性（A：Avaliability）、分区容错性（P：Partition Tolerance）这三个基本需求，最多同时满足两个
        * C：数据在多个副本中要保持强一致，比如前面说的分布式数据一致性问题。
        * A：系统对外提供的服务必须一直处于可用状态，在任何故障下，客户端都能在**合理的时间**内获得服务端的**非错误响应**。
        * P：**在分布式系统中遇到任何网络分区故障，系统仍然能够正常对外提供服务**。
        
        * AP：**对于AP来说，相当于放弃了强一致性，实现最终的一致，这是很多互联网公司解决分布式数据一致性问题的主要选择**。
        * CP：**放弃了高可用性，实现强一致性。前面提到的两阶段提交和三阶段提交都采用这种方案。可能导致的问题是用户完成一个操作会等待较长的时间**。
    * BASE理论：核心思想是通过牺牲数据的强一致性来获得高可用性。它有如下三个特性。
        * Basically Available（基本可用）：分布式系统在出现故障时，**允许损失一部分功能的可用性**，保证核心功能的可用。
        * Soft State（软状态）：允许系统中的数据存在中间状态，这个状态不影响系统的可用性，也就是**允许系统中不同节点的数据副本之间的同步存在延时**。
        * Eventually Consistent（最终一致性）：中间状态的数据在经过一段时间之后，会达到一个**最终的数据一致性**。
     
* 分布式事务问题的常见解决方案：
    * 基于CP的强一致性方案在**数据库性能和系统处理能力上会存在一定的瓶颈**。所以在互联网场景中更多采用**柔性事务**，所谓的**柔性事务是遵循BASE理论来实现的事务模型，它有两个特性：基本可用、柔性状态**。

* TCC补偿性方案：TCC（Try-Cofirm-Cancel）是一种比较成熟的分布式数据一致性解决方案，它实际上是把一个完整的业务拆分为如下三个步骤。
    * Try：这个阶段主要对数据的校验或者资源的预留。
    * Confirm：确认真正执行的任务，只操作Try阶段预留的资源。
    * Cancel：取消执行，释放Try阶段预留的资源。

* 基于可靠消息的最终一致性方案：主要利用消息中间件（Kafka、RocketMQ或RabbitMQ）的可靠性机制来实现数据一致性的投递。
    * 以电商平台的支付场景为例，用户完成订单的支付后不需要同步等待支付结果，可以继续做其他事情。支付服务收到支付结果通知后，先更新支付订单的状态，再发送一条消息到分布式消息队列中，账户服务会监听到指定队列的消息并进行相应的处理，完成数据的同步。
    * 问题：就是支付服务的本地事务与发送消息这个操作的原子性问题。
        * 先发送消息，再执行数据库事务，在这种情况下可能会出现消息发送成功但是本地事务更新失败的情况，仍然会导致数据不一致的问题。
        * 先执行数据库事务操作，再发布消息，在这种情况下可能会出现MQ响应超时导致异常，从而将本地事务回滚，但消息可能已经发生成功了，也会存在数据不一致的问题。
    * 成熟的解决方案，**以RocketMQ为例，它提供了事务消息模型，具体的执行逻辑如下**：
    * 生产者发送一个事务消息到消息队列上，消息队列只记录这条消息的数据，此时消费者无法消费这条消息。
    * 生产者执行具体的业务逻辑，完成本地事务的操作。
    * 接着生产者根据本地事务的执行结果发送一条确认消息给消息队列服务器，如果本地事务执行成功，则发送一个Commit消息，表示在第一步中**发送的消息可以被消费**，否则，消息队列服务器会把第一步存储的消息删除。
    * 如果生产者在执行本地事务的过程中因为某些情况一直未给消息队列服务器发送确认，那么**消息队列服务器会定时主动回查生产者**获取本地事务的执行结果，然后根据回查结果来决定这条消息是否需要投递给消费者。
    * 消息队列服务器上存储的消息被生产者确认之后，消费者就可以消费这条消息，消息消费完成之后发送一个确认标识给消息队列服务器，标识该消息投递成功。


* 最大努力通知型：最大努力通知型和基于可靠消息的最终一致性方案的实现是类似的，它是一种比较简单的柔性事务解决方案，也比较适用于对数据一致性要求不高的场景，最典型的使用场景是支付宝支付结果通知。实现流程如下：
    * 商户先创建一个支付订单，然后调用支付宝发起支付请求。
    * 支付宝唤醒支付页面完成支付操作，支付宝同样会针对该商户创建一个支付交易，并且根据用户的支付结果记录支付状态。
    * 支付完成后触发一个回调通知给商户，商户收到该通知后，根据结果修改本地支付订单的状态，并且返回一个处理状态给支付宝。
    * 针对这个订单，在理想状态下支付宝的交易状态和商户的交易状态会在通知完成后达到最终一致。**但是由于网络的不确定性，支付结果通知可能会失败或者丢失，导致商户端的支付订单的状态是未知的。所以最大努力通知型的作用就体现了，如果商户端在收到支付结果通知后没有返回一个“SUCCESS”状态码，那么这个支付结果回调请求会以衰减重试机制（逐步拉大通知的间隔）继续触发，比如1min、5min、10min、30min……直到达到最大通知次数**。如果达到指定次数后商户还没有返回确认状态，怎么处理呢？
    * 支付宝提供了一个交易结果查询接口，可以根据这个支付订单号去支付宝查询支付状态，然后根据返回的结果来更新商户的支付订单状态，这个过程可以通过定时器来触发，也可以通过人工对账来触发。


* 分布式事务框架Seata：
    * 提供了AT、TCC、Saga和XA事务模式，为开发者提供了一站式的分布式事务解决方案。

AT模式：Seata最主推的分布式事务解决方案，它是基于XA演进而来的一种分布式事务模式，所以它同样分为三大模块，分别是**TM、RM和TC，其中TM和RM作为Seata的客户端与业务系统集成，TC作为Seata的服务独立部署**。**TM表示事务管理器（Transaction Manager），它负责向TC注册一个全局事务，并生成一个全局唯一的XID**。在AT模式下，**每个数据库资源被当做一个RM（Resource Manager），在业务层面通过JDBC标准的接口访问RM时，Seata会对所有请求进行拦截。每个本地事务进行提交时，RM都会向TC（Transaction Coordinator，事务协调器）注册一个分支事务**。
    * 具体执行流程如下：
            * TM向TC注册全局事务，并生成全局唯一的XID。
            * RM向TC注册分支事务，并将其纳入该XID对应的全局事务范围。
            * RM想TC汇报资源的准备状态。
            * TC汇总所有事务参与者的执行状态，决定分布式事务是全部回滚还是提交。
            * TC通知所有RM提交/回滚事务。

* Saga模式：又称为长事务解决方案，**主要描述的是在没有两阶段提交的情况下如何解决分布式事务问题**。其核心思想是：**把一个业务流程中的长事务拆分为多个本地短事务，业务流程中的每个参与者都提交真实的提交给该本地短事务，当其中一个参与者事务执行失败，则通过补偿机制补偿前面已经成功的参与者**。
    * Saga的优劣势：
        * 和XA或者TCC相比，它的优势包括：**一阶段直接提交本地事务；没有锁等待，性能较高；在事件驱动的模式下，短事务可以异步执行；补偿机制的实现比较简单**。
        * 缺点是：**Saga并不提供原子性和隔离性支持，隔离性的影响是比较大的，比如用户购买一个商品后系统赠送一张优惠券，如果用户已经把优惠券使用了，那么事务如果出现异常要回滚时就会出现问题**。
    * Saga的实现方式：
        * 事件/编排式：**把Saga的决策和执行顺序逻辑分布在Saga的每一个参与者中，它们通过交换事件的方式来进行沟通**。
        * 命令/协同式：**把Saga的决策和执行顺序逻辑集中在一个Saga控制类中，它以命令/回复的方式与每项服务进行通信，告诉他们应该执行哪些操作**。

* Seata：
    * file存储模式：Server端存储模式（store.mode）有file、db两种（后续将引入Raft实现Seata的高可用机制），file存储模式无须改动，直接启动即可。File存储模式为单机模式，全局事务会话信息持久化在本地文件${SEATA_HOME}\bin\sessionStore\root.data中，性能较高。
    * db存储模式为高可用模式，全局事务会话信息通过db共享，性能相对差一些。
    * Seata服务端配置中心说明：在${SEATA_HOME}\conf目录下有两个配置文件，分别是registry.conf和file.conf。
        * registry.conf：包含两项配置。
            * registry：表示配置Seata服务注册的地址。
            * config：配置用于配置Seata服务端的配置文件地址。
        * file.conf：存储的是Seata服务端的配置信息。
    * Seata AT模式的实现原理：
        * 第一阶段：业务数据和回滚日志记录在同一个本地事务中提交，释放本地锁和连接资源。
            * 原理：Seata会基于数据源代理对原执行的SQL进行解析。
        * 第二阶段：提交异步化，非常快速地完成。回滚通过第一阶段的回滚日志进行反向补充。
            * 原理：清理UNDO_LOG日志即可。
    * 关于事务的隔离性保证：
        * 事务隔离性保证：基于全局锁来实现的。
            * 写隔离：在第一阶段本地事务提交之前，确保拿到全局锁。如果拿不到全局锁，则不能提交本地事务。并且获取全局锁的尝试会有一个范围限制。如果超出范围将会放弃全局锁的获取，并且回滚事务，释放本地锁。





















