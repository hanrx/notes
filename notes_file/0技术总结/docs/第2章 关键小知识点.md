
# 第2章 关键小知识点

## Spring：
* Spring Cloud：
    * 在Spring-Cloud-Common包中有一个类org.springframework.cloud.client.serviceregistry.ServiceRegistry，它是Spring Cloud提供的服务注册的标准。
    * Spring Cloud Alibaba Dubbo集成Nacos时，服务的注册是依托Dubbo中的自动装配机制完成的。
    * @EventListener的声明，它会监听ApplicationStartedEvent事件（Spring Boot 2.0新增的事件），该事件是在刷新上下文之后、调用application命令之前触发的。
    * 在所有配置信息被使用之前，bootstrap.yml文件要先读取。



* 注解：
    * @RestController：类级别Java注解，它告诉Spring容器这个Java类将用于基于REST的服务。此注解自动处理以JSON或XML方式传递到服务中的数据的序列化（在默认情况下，@RestController类将返回的数据序列化为JSON）。与传统的Spring @Controller注解不同，@RestController注解并不需要开发者从控制器类返回ResponseBody类。这一切都由@RestConstroller注解进行处理，它包含了@ResponseBody注解。
    * @RequestMapping：类级注解和方法级注解。@RequestMapping注解用于告诉Spring容器该服务将要公开的HTTP端点。使用类级的@RequestMapping注解时，将为该控制器公开的所有其他端点建立URL的根。
        * @PathVariable：用于将在传入的URL中传递的参数值（由{parameterName}语法表示）映射为方法的参数。
    * @Value("${XXX}")：注入配置。
    @RefreshScope：允许开发访问/refresh端点，强制Spring Boot应用程序重新读取应用程序配置。只会重新加载应用程序自定义的Spring属性。





* 编码规范：
    * Google Java样式指南：https://google.github.io/styleguide/javaguide.html

* Map的线程安全：
    * SynchronizedMap：对传入的HashMap对象进行包装同步而已。
    * ConcurentHashMap：jdk8以前，分段加锁，分成16个桶，每次只加锁其中一个桶，而JDK 8又加入了红黑树和CAS算法实现。
    * HashTable：get/put方法被synchronized关键字修饰，是方法级别阻塞的。占用共享资源锁，导致只能一个线程操作get或put，而且get/put操作不能同时执行，效率非常低，不建议使用。
    
    



* 待进一步了解知识：
https://github.com/hornhuang/android_interviews
    * 设计模式：https://www.runoob.com/design-pattern/design-pattern-tutorial.html


## Java基础：
* String:
    * String：常量、不可变对象，修改即创建新对象。
    * StringBuffer：变量、线安、使用时最好指定容量，快30%-40%。
    * StringBuilder：变量、线不安。
* List：
    * vector：线安、基于object[]arrary实现、随机访问O(1)。
    * arraylist：线不安、基于object[]arrary实现、随机访问O(1)。
    * linkedlist：线不安、随机访问O(n)、插入删除较arraylist快很多、比arraylist更占内存，因每个节点存储前后两个节点的引用。
* MAP：
    * Hashmap：非线安、实现Map接口、允许key-value均为null、hash默认16且均为2的指数。
    * HashTable：线安、实现Map接口、不允许key-value均为null、hssh默认11,增加方式old*2+1。
    * TreeMap：保持数据根据key值进行排序，可指定排序方式，默认升序。
    * Map的线程安全：
        * SynchronizedMap：对传入的HashMap对象进行包装同步而已。
        * ConcurentHashMap：jdk8以前，分段加锁，分成16个桶，每次只加锁其中一个桶，而JDK 8又加入了红黑树和CAS算法实现。
        * HashTable：get/put方法被synchronized关键字修饰，是方法级别阻塞的。占用共享资源锁，导致只能一个线程操作get或put，而且get/put操作不能同时执行，效率非常低，不建议使用。
        > * ConcurrentHashMap和HashTable区别：当HashTable增大到一定程度，其性能急剧下降，因迭代时会被锁很长时间。ConcurrenHashMap引入分隔保证锁的个数不会很大。简而言之，HashTable会锁整个map而ConcurrentHashMap只需锁住map的一部分。
* 服务器：
    * Tomcat：servlet容器、用于解析jsp、servlet。轻量级高效容器，缺点不支持EJB，只可用于Java应用。
    * Apache：http服务器、类似IIS用于建立虚拟站点，便于处理静态页面、支持SSL技术、支持多个虚拟主机。
    * Jboss：应用服务器、运行EJB的javaee应用服务器、最新javaee规范，能提供更多平台支持和更多集成功能、对servlet支持是集成其他servlet容器实现如tomcat。
* GET、POST区别：
    * get：从服务器获取数据、参数url可看到、服务端用request.QueryString获取变量值、安全性低效率高。
    * post：向服务器发送数据、通过HTTPpost机制，将表单各个字段放置在html header内、服务端用request.From获取数据、安全性高效率低。
* SESSION、COOKIE区别：
    * session：数据在一定时间内保存在服务器、访问增多占用服务器的性能。
    * cookie：数据在浏览器、不安全，可分析出本地cookit进行cookit欺骗、单个cookit不超过4k、很多浏览器限制站点最多保存20个cookie。
* Servlet生命周期：
    * 三阶段：初始化 调用init()、响应客户请求 调用service()、终止阶段 调用destroy方法。具体生命周期包括：装载Servlet、服务器创建Servlet实例、服务器调用Servlet的init()方法、客户请求到的服务器、服务器创建请求对象、服务器创建响应对象、服务器激活Servlet的service方法、请求对象和响应对象作为service()方法参数、service()方法获得关于请求对象的信息、处理请求、访问其他资源、获得需要的信息、service()方法可能激活其他方法以处理请求，如doGet()、doPost()。
* redirect、forward区别：
    * redirect：服务器发送状态码，告诉浏览器重新请求那个地址、地址栏是新url、不能共享数据、用于注销。
    * forward：服务器访问资源，直接访问目标地址url，把响应内容读取过来再发送给浏览器，地址栏不变、可共享request中数据、用于登录。
* Java对象内存模型：Java新建的对象放在堆里。
* Hibernate 一级和二级缓存的作用：
    > 一级缓存：是session基本的缓存，是内置不能卸载。一个Session做了查询，会把结果放在一级缓存，短时间这个session又做了同一操作，hibernate就直接从一级缓存获取数据。
    > 二级缓存：SessionFactory的缓存：分内置缓存和外置缓存两类。即查询结果放在二级缓存中，如果一个sessionFactory创建的某个session执行了相同的操作，hibernate就会从二级缓存中获取结果。适合放在二级缓存中的数据包括：很少被修改的数据，不是很重要的数据，允许出现偶偶并发的数据，不会被并非访问的数据，参考数据。不适合放在二级缓存中数据：经常被修改的数据、财务数据，绝对不允许出现并发、与其他营业共享的数据。
* 反射：能够分析类能力的程序称为反射。可以用来：分析类的能力，在运行中查看对象。实现通用的数据操作代码。反射性能优化方法：主要是设置不做安全检查。
* 线程同步，并发操作怎么控制：线程同步就是多个线程在逻辑上互有因果关系，所以要对其执行顺序进行协调。线程并发是指在同一时间间隔内，多个线程同时执行。如果线程在时间上能够区分，可以指定线程休眠时间来进行同步，可以用sleep()方法完成。如果线程在时间上不能区别，但在逻辑顺序上可以区分的话，那么就用join()方法来完成，一个先执行完，然后执行另一个。如果线程设计较为复杂，那么就通过wait()，notify()方法来完成。
* sql的优化相关问题：
    * 对查询优化，避免全表扫描。
    * 尽量避免where子句中对字段进行null值判断，否则将导致引擎放弃使用索引而进行全表扫描。
    * 尽量避免where子句中出现!=或<>，否则将导致引擎放弃使用索引而进行全表扫描。
    * 尽量避免where子句中出现or来连接条件。
    * 慎用in和not in,否则导致全表扫描。
    * where中不用用函数操作。
    * Update语句，如果只更改1、2个字段，不要update全部字段，否则频繁调用会引起明显的性能消耗，同时带来大量日志。
    * 对于多张大数据量（这里几百条就算大了）的表JOIN，要先分页再JOIN，否则逻辑读会很高，性能很差。
    * 尽可能使用varchar/nvarchar代替char/nchar，节省空间，提高查询效率。
    * select count(*) from table；这样不带任何条件的count会引起全表扫描，并且没有任何业务意义，一定要杜绝的。
* DB中索引原理、种类、使用索引的好处和问题：
    * 原理：因为检索磁盘对比数据，需要大量的时间和IO，所以需要构造某列数据的btree、hash值、位图索引。一般的索引能快速对比，而索引的值记录了磁盘的位置，直接读取数据库字段对应位置的内容。
    * 索引好处：加快数据检索速度、加速表与表之间的连接特别是实现数据的参考完整性方面特别有意义、减少查询中分组和排序的时间，使用优化隐藏器，提高系统性能。
    * 缺点：创建和维护索引需要时间，索引需要占用物理空间，当对表中的数据进行增删改时也需要动态维护。
* JVM垃圾回收实现原理。垃圾回收线程优先级。
    > JVM的堆空间中主要分为年轻代、老年代和永久代。年轻代和老年代是存储动态产生的对象。永久代主要是存储java类信息，包括解析得到的方法属性、字段等等。永久代基本不参数垃圾回收。年轻代分为一个eden区和两个相同的survior区。刚开始创建的对象都放置在eden区。这样主要是为了将生命周期短的对象尽量留在年轻态。当eden区申请不到空间时，进行minorGC，把存活的对象拷贝到survior。年老代主要存放生命周期比较长的对象，如缓存对象。具体JVM回收过程如下：
    > 1. 对象在Eden去完成内存分配。
    > 2. 当Eden区满了，在创建对象就会申请不到空间，则触发minorGc，进行young（eden去和1survior区的垃圾回收）。
    > 3. 在minorGc时，Eden不能被回收的对象则放入survior（即Eden肯定被清空），另一个survior里不能被GC回收的也会被放入这个survivor，始终保持一个survior是空的。
    > 4. 当完成第三步的时候、如果发现survivor满了，则这些对象copy到old区，或者survior并没有满，但有些对象已经够old了，也被放入到old去。当old区被放满之后，进行fullGC。
* JVM最大内存设置。设置的原理：
    > JVM内存分为堆内存和非堆内存，堆内存给开发人员用的，非堆内存给JVM本身用的，用来存放类型信息，及时GC时也不会释放空间。    
    > 堆内存设置：    
        > -Xms：初始堆内存，默认物理存储1/64，也是最小分配堆内存，当空余堆内存小于40%时，会增加到-Xms的最大限制。    
        > -Xmx：最大堆内存分配，默认物理存储1/4，当空余堆内存小于70%时，会减少到-Xms的最小限制。    
    > 非堆内存设置：   
        > -XX:PermSize：非堆内存的初始值，默认物理存内存的1/64，也是最小非堆内存。  
        > -XX:MaxPermSize：非堆内存最大值，默认物理内存的1/4。   
* 查看堆大小命令为：Runtime.getRuntime().maxMemory()。
* JVM通过参数调整内存大小：通过环境变量 JAVA_OPTS。
* 进程与线程的区别：线程是进程的一个单位，也就是进程内的可调度实体。区别是：1.进程内的线程共享地址空间，进程则自己独立的地址空间。2.进程是资源分配和拥有的耽误，同一个进行内的线程共享进程资源。3.线程是处理器调度的基本耽误。4.两者均可并发执行。
* 怎样避免死锁：
    > * 使用事务时，尽量缩短事务逻辑处理过程，及早提交或回滚事务。   
    > * 设置死锁的超时参数为合理范围3-10分钟，若超过时间，自动放弃本次操作，避免进程悬挂。
    > * 优化程序，检查并避免死锁现象出现。
    > * 对所有的脚步和sp都要仔细测试。
    > * 对所有的sp都要有错误处理。
    > * 一般不要修改sql事务的默认级别，不推荐强行加锁。
* 垃圾回收算法使用的产品、场景：
    * 标记-清除算法：标记阶段，确定所有要回收的对象，并标记，清除阶段则将需要回收的对象清除。
    * 复制算法：把内存分为大小相等的两块，每次使用其中的一块，当垃圾回收时，把存活的对象复制到另一块上，然后把这块内存整个清理掉。两块内存比是8:1。
    标记整理算法：把存活的对象往内存的一端移动，然后直接回收边界以外的内存。标记-整理算法提高了内存的利用率，并且它适合在收集存活时间较长的老年代。
    分代回收算法：根据对象的存活时间把内存分为新生代和老年代，根据各对象的存活特点，每代采用不同的GC算法，新生代用标记-复制算法，老年代用标记-整理算法。
* 实际项目中JVM调优：
    * JVM启动参数：调整各代内存比例和垃圾回收算法，提供吞吐量。
    * 改进程序逻辑算法，提高性能。
    * 自定义封装线程池，解决用户响应时间长的问题。比如设置线程最小数量、最大数量。
    * 连接池。
* JDK并发包的集合介绍：
    Map并发包：实现为ConcurrentHashMap，它实现了ConcurrentMap接口。put方法为根据计算出的hash值去获取segment对象。找到segment对象后调用该对象的put方法完成操作。segment中的put方法是先加锁，之后判断数组大小，然后觉得是否扩充。然后得到key索引要放置的位置。
    List并发包：在高并发环境下使用CopyOnWriteArrayList代替ArrayList。添加元素是利用数组的copy功能和加锁机制。并发情况下，CopyOnWriteArrayList比ArrayList略快一些。
    set并发：CopyOnWriteSet和CopyOnWriteArrayList底层实现差不多就是在添加元素时会进行唯一性判断，如果对象数组已经包含有重复元素，不进行增加处理。
    queue并发：并发类是ArrayBlockingQueue，底层为数组，并对关键的方法入队、出队操作加入了锁队机制。
    Atomic系列类：比如AtomicInteger类，通过使用计数器操作时，一般为了避免线程安全问题，在方法上加锁操作。有了并发包下的原子系列列，我们可以直接使用。
* 线程之间的通信：主要包括互斥锁、条件变量、读写锁和线程信号灯。
    * 互斥锁：以排他方式防止数据被并发修改。互斥锁两个状态0和1。具体为申请锁、占用锁以防止数据被修改，此时默认阻塞等等，最后释放锁。
    * 条件变量通信机制：原理，条件变量出现时，可以弥补互斥锁的缺陷，有些问题仅仅依靠互斥锁无法解决。但条件变量不能单独使用，必须配合互斥锁一起实现对资源的互斥访问。
    * 读写锁：在对数据读写时，往往读占主要部分。基本原则是如果其他线程读数据，则允许其他线程执行读操作，但不允许写操作。如果有其他操作申请写操作，则其他线程不能申请读操作和写操作。
    * 线程信号：线程拥有与信号相关的私有数据——线程信号掩码。线程可以向别的线程发送信息，每个线程可以设置自己的阻塞集合。所有线程中，同一个信号子任何线程里的对该信号的处理一定相同。
* threadlocal：可以叫做线程本地变量或线程本地存储。ThreadLocal为变量在每个线程中都创建了一个副本，每个线程都可以访问自己的内部副本变量。但可能这样做导致内存占用较大。ThreadLocal类的几个方法：get()用来获取ThreadLocal在当前线程中保存的变量副本，set()用来设置当前线程中变量的副本，remove()用来移除当前线程中变量副本，initialValue()一般用来在使用时进行重写，是一个延迟加载方法。最常见的ThreadLocal使用场景是用来解决数据库连接、Session管理等。
* Java内存泄漏：内存对象已经不需要时，还保留这块内存和它的访问方式（引用），由于Java GC机制。
* final字段总结：
    * final类：不能被继承，其方法也是默认final类型。
    * final方法：不能被子类覆盖，但可以继承。
    * final变量：表示常量，只能被赋值一次，赋值后不改变。
    * final不能用于构造方法。
        


## Redis
* 键值对（key-value pair）都是由对象组成。
    * 数据库键：总是一个字符串对象。
    * 数据库键值：字符串对象、列表对象、哈希对象、集合对象、有序集合对象。五种对象中的一种。
* 简单动态字符串（SDS）：
    * SDS：作为Redis默认字符串表示。
        * 原因：记录并获取字符串长度、杜绝缓冲区溢出、减少修改字符串时带来内存重分配次数。
        * 空间分配策略：1M下，当前字符串长度N,n+n+1byte、大于1M，size+1M+1byte。
        * 惰性空间释放：缩短SDS保持字符串时，不立即内存重分配，而是free属性记录起来。
        * 二进制安全：因C字符串不能包含空字符。
* 链表：提供高效节点重排能力，以及顺序性节点访问方式，可通过增删节点来灵活调整链表长度。
    * 应用场景：列表键底层实现之一就是链表。发布与订阅、慢查询、监视器等功能也用到了链表、Resis服务器使用链表保持多个客户端状态信息，以及用链表构建客户端输出缓冲区。
    * 特性：双端（prev和next指针）。无环(表头/表尾节点的指针指向null)
* 字典：又成符号表、关联数组、映射。是一种用于保持键值对的抽象数据结构。
    * 键独一无二。Redis数据库使用字典作为底层实现。哈希键的底层实现之一。
    * 实现：使用哈希表作为底层实现。
    * rehash：是哈希表的负载因子维持在一个合理的范围内。
    * 渐进式rehash：
* 跳跃表（skiplist）：是一种有序数据结构。通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。使用跳跃表作为有序集合键的底层实现。集群节点中作为内部数据结构。
* 整数集合：集合键的底层实现之一。只支持升级操作，不支持降级操作。
* 压缩列表：列表键和哈希键的底层实现之一。是Redis为节约内存而开发的，是由一系列特殊编码的连续内存块组成的顺序型数据结构。
* 对象：Redis并没有直接使用用到的主要数据结构 动态字符串（SDS）、双端链表、字典、压缩列表、整数集合等等，而是基于这些数据结构创建了一个对象系统，这个系统包含对象、列表对象、哈希对象、集合对象和有序集合对象这五种类型的对象，每种对象都用到了至少一种我们前面介绍的数据结构。
    * Redis中每个对象都由一个redisObject结构表示，该结构中和保存数据有关的三个属性分别是type属性、encoding属性和pty属性：

* 数据库：
















