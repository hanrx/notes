
* Spring：
    * Spring Cloud：
        * 在Spring-Cloud-Common包中有一个类org.springframework.cloud.client.serviceregistry.ServiceRegistry，它是Spring Cloud提供的服务注册的标准。
        * Spring Cloud Alibaba Dubbo集成Nacos时，服务的注册是依托Dubbo中的自动装配机制完成的。
        * @EventListener的声明，它会监听ApplicationStartedEvent事件（Spring Boot 2.0新增的事件），该事件是在刷新上下文之后、调用application命令之前触发的。
        * 在所有配置信息被使用之前，bootstrap.yml文件要先读取。



* 注解：
    * @RestController：类级别Java注解，它告诉Spring容器这个Java类将用于基于REST的服务。此注解自动处理以JSON或XML方式传递到服务中的数据的序列化（在默认情况下，@RestController类将返回的数据序列化为JSON）。与传统的Spring @Controller注解不同，@RestController注解并不需要开发者从控制器类返回ResponseBody类。这一切都由@RestConstroller注解进行处理，它包含了@ResponseBody注解。
    * @RequestMapping：类级注解和方法级注解。@RequestMapping注解用于告诉Spring容器该服务将要公开的HTTP端点。使用类级的@RequestMapping注解时，将为该控制器公开的所有其他端点建立URL的根。
        * @PathVariable：用于将在传入的URL中传递的参数值（由{parameterName}语法表示）映射为方法的参数。
    * @Value("${XXX}")：注入配置。
    @RefreshScope：允许开发访问/refresh端点，强制Spring Boot应用程序重新读取应用程序配置。只会重新加载应用程序自定义的Spring属性。





* 编码规范：
    * Google Java样式指南：https://google.github.io/styleguide/javaguide.html

* Map的线程安全：
    * SynchronizedMap：对传入的HashMap对象进行包装同步而已。
    * ConcurentHashMap：jdk8以前，分段加锁，分成16个桶，每次只加锁其中一个桶，而JDK 8又加入了红黑树和CAS算法实现。
    * HashTable：get/put方法被synchronized关键字修饰，是方法级别阻塞的。占用共享资源锁，导致只能一个线程操作get或put，而且get/put操作不能同时执行，效率非常低，不建议使用。
    
    



* 待进一步了解知识：
https://github.com/hornhuang/android_interviews
    * 设计模式：https://www.runoob.com/design-pattern/design-pattern-tutorial.html


* Java基础：
    * String:
        * String：常量、不可变对象，修改即创建新对象。
        * StringBuffer：变量、线安、使用时最好指定容量，快30%-40%。
        * StringBuilder：变量、线不安。
    * List：
        * vector：线安、基于object[]arrary实现、随机访问O(1)。
        * arraylist：线不安、基于object[]arrary实现、随机访问O(1)。
        * linkedlist：线不安、随机访问O(n)、插入删除较arraylist快很多、比arraylist更占内存，因每个节点存储前后两个节点的引用。
    * MAP：
        * Hashmap：非线安、实现Map接口、允许key-value均为null、hash默认16且均为2的指数。
        * HashTable：线安、实现Map接口、不允许key-value均为null、hssh默认11,增加方式old*2+1。
        * TreeMap：保持数据根据key值进行排序，可指定排序方式，默认升序。
        * Map的线程安全：
            * SynchronizedMap：对传入的HashMap对象进行包装同步而已。
            * ConcurentHashMap：jdk8以前，分段加锁，分成16个桶，每次只加锁其中一个桶，而JDK 8又加入了红黑树和CAS算法实现。
            * HashTable：get/put方法被synchronized关键字修饰，是方法级别阻塞的。占用共享资源锁，导致只能一个线程操作get或put，而且get/put操作不能同时执行，效率非常低，不建议使用。
            > * ConcurrentHashMap和HashTable区别：当HashTable增大到一定程度，其性能急剧下降，因迭代时会被锁很长时间。ConcurrenHashMap引入分隔保证锁的个数不会很大。简而言之，HashTable会锁整个map而ConcurrentHashMap只需锁住map的一部分。
    * 服务器：
        * Tomcat：servlet容器、用于解析jsp、servlet。轻量级高效容器，缺点不支持EJB，只可用于Java应用。
        * Apache：http服务器、类似IIS用于建立虚拟站点，便于处理静态页面、支持SSL技术、支持多个虚拟主机。
        * Jboss：应用服务器、运行EJB的javaee应用服务器、最新javaee规范，能提供更多平台支持和更多集成功能、对servlet支持是集成其他servlet容器实现如tomcat。
    * GET、POST区别：
        * get：从服务器获取数据、参数url可看到、服务端用request.QueryString获取变量值、安全性低效率高。
        * post：向服务器发送数据、通过HTTPpost机制，将表单各个字段放置在html header内、服务端用request.From获取数据、安全性高效率低。
    * SESSION、COOKIE区别：
        * session：数据在一定时间内保存在服务器、访问增多占用服务器的性能。
        * cookie：数据在浏览器、不安全，可分析出本地cookit进行cookit欺骗、单个cookit不超过4k、很多浏览器限制站点最多保存20个cookie。
    * Servlet生命周期：
        * 三阶段：初始化 调用init()、响应客户请求 调用service()、终止阶段 调用destroy方法。具体生命周期包括：装载Servlet、服务器创建Servlet实例、服务器调用Servlet的init()方法、客户请求到的服务器、服务器创建请求对象、服务器创建响应对象、服务器激活Servlet的service方法、请求对象和响应对象作为service()方法参数、service()方法获得关于请求对象的信息、处理请求、访问其他资源、获得需要的信息、service()方法可能激活其他方法以处理请求，如doGet()、doPost()。















