# Sentiel
* 官网：
  * http://github.com/alibaba/sentinel
  * 中文： https://github.com/alibaba/Sentinel/wiki  
* 是什么：一句话，之前我们讲过的Hystrix
  > ![img.png](img.png)
  > ![img_1.png](img_1.png)
* 去哪下：https://github.com/alibaba/Sentinel/releases
  > ![img_2.png](img_2.png)
* 能干嘛：
  > ![img_3.png](img_3.png)
* 怎么玩：
  * https://spring-cloud-alibaba-group.github.io/github-pages/greenwich/spring-cloud-alibaba.html#spring_cloud_alibaba_sentinel
  * 服务使用中的各种问题：
    * 服务雪崩
    * 服务降级
    * 服务熔断
    * 服务限流

# 安装Sentielk控制台
* sentinel由2部分组成：
  * 后台：核心库（Java客户端）不依赖任何框架/库，能够运行于所有Java运行时环境，同时对Dubbo / Spring Cloud等框架也有较好的支持。
  * 前台8080：控制台（Dashboard）基于Spring Boot开发，打包后可以直接运行，不需要额外的Tomcat等应用容器。
* 安装步骤：
  * 下载：https://github.com/alibaba/Sentinel/releases：下载到本地sentinel-dashboard-1.7.0.jar
    > ![img_4.png](img_4.png)
  * 运行命令：
    * 前提：java环境OK。8080端口不能被占用
    * 命令：java -jar sentinel-dashboard-1.7.0.jar
  * 访问sentinel管理界面：
    * http://localhost:8080
      > ![img_5.png](img_5.png)
    * 登录账号密码均为sentinel

# 初始化演示功能
* 启动Nacos8848成功：http://localhost:8848/nacos/#/login
* 新建Module：
  * cloudalibaba-sentinel-server8401
  * POM：
    > ![img_6.png](img_6.png)
  * YML：
    > ![img_7.png](img_7.png)\
  * 主启动类：
    > ![img_8.png](img_8.png)
  * 业务类FloLimitController：
    > ![img_9.png](img_9.png)
* 启动Sentinerl8080：java -jar sentinel -dashboard-1.7.0.jar
* 启动微服务8401
* 启动8401微服务后查看sentinel控制台:
  * 空空如也，什么也没有
    > ![img_10.png](img_10.png)
  * sentinel采用的是懒加载说明：
    * 访问一次即可：
      * http://localhost:8401/testA
      * http://localhost:8401/testB
    * 效果：
      > ![img_11.png](img_11.png)

# 流控规则
* 基本介绍：
  > ![img_12.png](img_12.png)
  > 进一步解释说明：
  > * 资源名：唯一名称，默认请求路径
  > * 针对来源：Sentinel可以针对调用者进行限流，填写微服务名，默认default（不区分来源）
  > * 阈值类型/单机阈值：
  >   * QPS（每秒钟的请求数量）：当调用该api的QPS达到阈值的时候，进行限流。
  >   * 线程数：当调用该api的线程数达到阈值的时候，进行限流。
  > * 是否集群：不需要集群
  > * 流控模式：
  >   * 直接：api达到限流条件时，直接限流。
  >   * 关联：当关联的资源达到阈值时，就限流自己
  >   * 链路：只记录指定链路上的流量（指定资源从入口资源进来的流量，如果达到阈值，就进行限流）【api级别的针对来源】
  > * 流控效果：
  >   * 快速失败：直接失败，抛异常
  >   * Warm UP：更加codeFactor（冷加载因子，默认3）的值，从阈值/codeFactor，经过预热时长，才达到设置的QPS阈值
  >   * 排队等待：匀速排队，让请求以匀速的速度通过，阈值类型必须设置为QPS，否则无效
* 流控模式：
  * 直接（默认）：
    * 直接：快速失败，系统默认。
    * 配置及说明：
      > ![img_13.png](img_13.png)
      > * 阈值类型：
      >   * QPS：御敌于国外。
      >   * 线程数：关门打狗。
    * 测试：
      * 快速点击访问：http://localhost:8401/testA
      * 结果：Blocked by Sentinel(flow limiting)
      * 思考：直接调用默认报错信息，技术方面OK，but，是否应该由我们自己的后续处理？类似于有个fallback的兜底方法.
  * 关联：
    * 是什么：
      * 当关联的资源达到阈值时，就限流自己
      * 当与A关联的的资源B达到阈值后，就限流自己：支付接口达到阈值后，就限流下订单的接口，防止连坐效应。
      * B惹事，A挂了。
    * 配置：
      > 设置效果
      > 当关联资源testB的qps阀值超过1时，就限流/testA的Rest访问地址，当关联资源到阈值后限制配置好的资源名
      > ![img_14.png](img_14.png)
    * postman模拟并发密集访问testB：
      > ![img_15.png](img_15.png)
      > * 访问testB成功：![img_16.png](img_16.png)
      > * postman里新建多线程集合组：![img_17.png](img_17.png)
      > * 将访问地址添加进新线程组：![img_18.png](img_18.png)
      > * Run：大批量线程高并发访问B,导致A失效了
    * 运行后发现testA挂了：
      * 点击访问http://localhost:8401/testA
      * 结果：Blocked by Sentinel(flow limiting)
  * 链路：
    * 多个请求调用同一个微服务。
* 流控效果：
  * 直接：快速失败（默认的流控处理）
    * 直接失败，抛出异常：Blocked by Sentinel（flow limiting）
    * 源码：com.alibaba.csp.sentinel.slots.block.flow.controller.DefaultController
  * 预热：
    * 说明：公式：阈值除以coldFactor（默认值为3），经过预热时长后才会达到阈值。
    * 官网：
      > ![img_19.png](img_19.png)
      > ![img_20.png](img_20.png)
      > * 默认coldFacotor为3，即请求QPS从threshold/3开始，经预热时长逐渐升至设定的QPS阈值
      > * 限流冷启动：https://github.com/alibaba/Sentinel/wiki/限流---冷启动
    * 源码：
      > ![img_21.png](img_21.png)
      > ![img_22.png](img_22.png)
    * WarmUP配置：
      > ![img_23.png](img_23.png)
    * 多次点击http://localhost:8401/testB
    * 应用场景：如：秒杀系统在开启的瞬间，会有很多流量上来，很可能把系统打死，预热方式就是为了保护系统，可慢慢的把流量放进来，慢慢的把阀值增加到设置的阀值。
  * 排队等待：
    * 匀速排队，阈值必须设置为QPS：
      > ![img_25.png](img_25.png)
      > 匀速排队：
      > 匀速排队（RuleConstant.CONTROL_BEHAVIOR_RATE_LIMITER）方式会严格控制请求通过的间隔时间，也即是让请求以均匀的速度通过，对应的是漏桶
      > 算法。详细文档可以参考 流量控制-匀速器模式，具体的例子可以参见PaceFlowDemo。
      > 该方式的作用如图所示：
      > 这种方式主要用于处理间隔性突发的流量，例如消息队列。想象一下这样的场景，在某一秒有大量的请求到来，而接下来的几秒则处于空闲状态，我们希望系统能够
      > 在接下来的空闲期间逐渐处理这些请求，而不是在第一秒直接拒绝多余的请求。
    * 源码：com.alibaba.csp.sentinel.slots.block.flow.controller.RateLimiterController
    * 测试：
      > ![img_26.png](img_26.png)
    > ![img_24.png](img_24.png)
    
# 降级规则
* 官网：https://github.com/alibaba/Sentinel/wiki/熔断降级
* 基本介绍：
  * 基本介绍：
    > ![img_27.png](img_27.png)
    > * RT（平均响应时间，秒级）
    >   平均响应时间 超出阈值 且 在时间窗口内通过的请求>=5，两个条件同时满足后触发降级。
    >   窗口期过后关闭断路器。
    >   RT最大4900(更大的需要通过-Dcsp.sentinel.statistic.max.rt=XXXX才能生效)
    > * 异常比例（秒级）：
    >   QPS >= 5 且异常比例（秒级统计）超过阈值时，触发降级；时间窗口结束后，关闭降级。
    > * 异常数（分钟级）：
    >   异常数（分钟统计）超过阈值时，触发降级；时间窗口结束后，关闭降级
  * 进一步说明：
    > Sentinel熔断降级会在调用链路中某个资源出现不稳定状态时（例如调用超时或异常比例升高），对这个资源的调用进行限制。让请求快速失败，避免影响
    > 到其他的资源而导致级联错误。
    > 
    > 当资源被降级后，在接下来的降级时间窗口内，对该资源的调用都自动熔断（默认行为是抛出DegradeException）。
  * Sentinel的断路器是没有半开状态的：
    * 半开的状态系统自动去检测是否请求一次，没有异常就关闭断路器恢复使用，有异常则继续打开断路器不可用，具体可以参考Hystrix
    * 复习Hystrix：
      > ![img_28.png](img_28.png) 
* 降级策略实战：
  * RT：
    * 是什么：平均响应时间：
      > 平均响应时间（DEGRADE_GRADE_RT）：当1s内持续进入5个请求，对应时刻的平均响应时间（秒级）均超过阈值（count,以ms为单位），那么在接下来
      > 的时间窗口（DegradeRule中的timeWindow，以s为单位）之内，对这个方法的调用都会自动地熔断（抛出DegradeException）。注意Sentinel默认
      > 统计的RT上限是4900ms，超出此阈值的值都会算作4900 ms，若需要变更此上限可以通过启动配置项 -Dcsp.sentinel.statistic.max.rt-xxx来配置。
      > ![img_29.png](img_29.png)
    * 测试：
      * 代码：
        > ![img_30.png](img_30.png)
      * 配置：
        > ![img_31.png](img_31.png)
      * jmetter压测：
        > ![img_32.png](img_32.png)
      * 结论：
        > ![img_33.png](img_33.png)
  * 异常比例：
    * 是什么：
      > 异常比例（DEGRADE_GRADE_EXCEPTION_RATIO）：当资源的每秒请求量>=5，并且每秒异常总数占通过量的比值超过阈值（DegradeRule中的count）
      > 之后，资源进入降级状态，即在接下来的时间窗口（DegradeRule中的timeWindow，以s为单位）之内，对这个方法的调用都会自动地返回。异常比例的
      > 阈值访问是[0.0,1.0],代表0%-100%。
      > ![img_34.png](img_34.png)
    * 测试：
      * 代码：
        > ![img_35.png](img_35.png)
      * 配置：
        > ![img_36.png](img_36.png)
      * jmeter压测：
        > ![img_37.png](img_37.png)
      * 结论：
        > ![img_38.png](img_38.png)
  * 异常数：
    * 是什么：
      > 异常数（DEGRADE_GRADE_EXCEPTION_COUNT）：当资源接近1分钟的异常数目超过阈值之后会进行熔断。注意由于统计时间窗口是分钟级别的，若timeWindow
      > 小于60s，则结束熔断状态后仍可能再进入熔断状态。
      > 
      > 时间窗口一定要大于等于60秒。
      > 
      > ![img_39.png](img_39.png)
    * 异常数是按分钟统计的：
    * 测试：
      * 代码：
        > ![img_40.png](img_40.png)
      * 配置：
        > ![img_41.png](img_41.png)
      * jmeter:

# 热点key限流
* 基本介绍：
  > ![img_42.png](img_42.png)
* 官网：https://github.com/alibaba/Sentine/wiki/热点参数限流
* 承上启下复习start: @SentinelResource
  > 兜底方法：分为系统默认和客户自定义，两种
  > 之前的case,限流出问题后，都是用sentinel系统默认的提示：Blocked by Sentinel（flow limiting）
  > 
  > 我们能不能自定义？类似Hystrix，某个方法出问题了，就对应的兜底降级方法？
  > 
  > 结论：从HystrixCommand到@SentineResource
* 代码：com.alibaba.csp.sentinel.slots.block.BlockException
  > ![img_43.png](img_43.png)
* 配置：
  * 1:
    * @SentinelResource(value="testHotKey")
    * 异常信息打到了前台用户界面看到，不友好：
      > ![img_45.png](img_45.png)  
  * 2:
    * @SentinelResource(value="testHotKey",blockHandler="dealHandler_testHotKey")
    * 方法testHotKey里面第一个参数只要QPS超过每秒1次，马上降级处理。
    * 用了我们自定义的。
  > ![img_44.png](img_44.png)
* 测试：
  > ![img_46.png](img_46.png)
* 参数列外项：
  * 上述案例演示了第一个参数p1,超过1秒钟后，达到阈值1后，马上被限流。
  * 特殊情况：
    * 普通：超过1秒钟后，达到阈值1后马上被限流。
    * 我们期望p1参数当它是某个特殊值是，它的限流和平时不一样
    * 特殊：假如当p1的值等于5时，它的阈值可以达到200。
  * 配置：
    > ![img_47.png](img_47.png)
  * 测试：
    > ![img_48.png](img_48.png)
  * 前提条件：热点参数注意点，参数必须是基本类型或者String。
* 其他：
  * 添加异常看看：
    > ![img_49.png](img_49.png)
    > ![img_50.png](img_50.png)
    > 
  * 总结：
    * @SentinelResource：处理的是Sentinel控制台配置的违规情况，有blockHandler方法配置的兜底处理：
    * RuntimeException：int age = 10/0 ,这是java运行时报出的运行时异常RunTimeException，@SentinelResource不管。


# 系统规则
* 是什么：https://github.com/alibaba/Sentine/wiki/系统自适应限流
* 各项配置说明：
  > 系统保护规则是从应用级别的入口流量进行控制，从单台机器的load、CPU使用率、平均RT、入口QPS和并发线程数等几个维度监控应用指标，让系统尽可能跑在
  > 最大吞吐量的同时保证系统整体的稳定性。
  > 
  > 系统保护规则是应用整体维度的，而不是资源维度的，并且仅对入口流量生效。入口流量值的是进入应用的流量（EntryTYpe.IN），比如Web服务或Dubbo服务
  > 端接收的请求，都属于入口流量。
  > 
  > 系统规则支持以下的模式：
  > * Load自适应（仅对Linux/Unix-like机器生效）：系统的load1作为启发指标，进入自适应系统保护。当系统load1超过设定的启发值，且系统当前的并发
  > 线程数超过估算的系统容量时才会触发系统保护（BBR阶段）。系统容量由系统的maxQps * minRt 估算得出。设定参考值一般是CPU cores * 2.5。
  > * CPU usage（1.5.0+ 版本）：当系统CPU使用率超过阈值即触发系统保护（取值范围0.0 - 1.0）,比较灵敏。
  > * 平均RT：当单台机器上所有入口流量的平均RT达到阈值即触发系统保护，单位是毫秒。
  > * 并发线程数：当单台机器上所有入口流量的并发线程数达到阈值即触发系统保护。
  > * 入口QPS：当单台机器上所有入口流量的QPS达到阈值即触发系统保护。
* 配置全局QPS：
  > ![img_51.png](img_51.png)
 

# @SentinelResource





# 服务熔断功能




# 规则持久化




# 
# 
# 


























